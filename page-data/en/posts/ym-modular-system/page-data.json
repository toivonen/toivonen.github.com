{"componentChunkName":"component---src-components-layout-layout-post-js","path":"/en/posts/ym-modular-system/","result":{"data":{"mdx":{"id":"040a55a6-de7a-55fd-844f-3cfcb70e78df","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"YM Modular System. Why?\",\n  \"categories\": \"en issues\",\n  \"old\": true,\n  \"date\": \"2014-02-25T00:00:00.000Z\",\n  \"layout\": \"post\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"The recently published \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://bem.info/tutorials/articles/bem-js-tutorial/\"\n  }), \"step-by-step tutorial on\\ni-bem.js\"), \" mentioned \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"YM\\nmodular system\"), \" as a base for component JavaScript solution behind BEM. Why do\\nwe need another modular system? Let us see...\"), mdx(\"excerpt\", null), mdx(\"p\", null, \"The author of YM modules, \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/dfilatov\"\n  }), \"Dmitry Filatov\"), \" recently\\ncame up with an \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://habrahabr.ru/post/213627/\"\n  }), \"article about YM modules\"), \" in\\nRussian. And below you can find the translation.\"), mdx(\"hr\", null), mdx(\"p\", null, \"So, one more modular system? Besides CommonJS and AMD? Why should we care?\"), mdx(\"p\", null, \"I will not write why modules and modular systems are needed, there are plenty of\\narticles about it. Let us rather proceed to the main question: why do we need\\n\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"another\"), \" modular system?\", mdx(\"br\", null), \"\\nFor sure, there are CommonJS and AMD, but working on large projects with them I faced\\nlarge drawbacks. One is that they are synchronous. This is not fatal, but in my\\nproject we often had to provie different hacks for it.\"), mdx(\"p\", null, \"Let us say, we have 3 modules: moduleA, moduleB and moduleC. moduleC depends on\\nboth moduleA and moduleB. Initially I will describe this in code for all the\\nthree solutions:\"), mdx(\"p\", null, \"####CommonJS\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"moduleA.js:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"module.exports = 'A';\\n\")), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"moduleB.js:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"module.exports = 'B';\\n\")), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"moduleC.js:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"var moduleA = require('A');\\n    moduleB = require('B');\\n\\nmodule.exports = moduleA + moduleB + 'C';\\n\")), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Linking and usage:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"var moduleC = require('C');\\nconsole.log(moduleC); // prints \\\"ABC\\\"\\n\")), mdx(\"p\", null, \"####AMD\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"moduleA.js:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"define('A', function() {\\n    return 'A';\\n});\\n\")), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"moduleB.js:\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"define('B', function() {\\n    return 'B';\\n});\\n\")), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"moduleC.js:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"define('\\u0421', ['A', 'B'], function(moduleA, moduleB) {\\n    return moduleA + moduleB + 'C';\\n});\\n\")), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Linking and usage:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"require(['\\u0421'], function(moduleC) {\\n    console.log(moduleC); // prints \\\"ABC\\\"\\n});\\n\")), mdx(\"p\", null, \"####YM\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"moduleA.js:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"modules.define('A', function(provide) {\\n    provide('A');\\n});\\n\")), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"moduleB.js:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"modules.define('B', function(provide) {\\n    provide('B');\\n});\\n\")), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"moduleC.js:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"modules.define('C', ['A', 'B'], function(provide, moduleA, moduleB) {\\n    provide(moduleA + moduleB + 'C');\\n});\\n\")), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Linking and usage:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"modules.require(['\\u0421'], function(moduleC) {\\n    console.log(moduleC); // prints \\\"ABC\\\"\\n});\\n\")), mdx(\"p\", null, \"Nothing interesting yet. All three examples are similar, although you may\\nnotice the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"provide\"), \" callback in the YM example. What is it for?\"), mdx(\"p\", null, \"Let us imagine a case that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"moduleA\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"moduleB\"), \" cannot be resolved immediately\\n(synchronously, as it is required by CommonJS and AMD). Sometimes you need to\\ndo an asynchronous action first. The simpliest example can be \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"setTimeout\"), \".\\nThere is no way to implement it elegantly with CommonJS and AMD.\\nBut with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"YM\"), \" it can be coded as follows:\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"moduleA.js:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"modules.define('A', function(provide) {\\n    setTimeout(function() {\\n        provide('A');\\n   });\\n});\\n\")), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"moduleB.js:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"modules.define('B', function(provide) {\\n    setTimeout(function() {\\n        provide('B');\\n    });\\n});\\n\")), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"moduleC.js:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"modules.define('C', ['A', 'B'], function(provide, moduleA, moduleB) {\\n    provide(moduleA + moduleB + 'C');\\n});\\n\")), mdx(\"p\", null, \"Interestingly \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"moduleC\"), \" does not know anything about asynchronous actions in\\nits dependant modules. \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Win!\")), mdx(\"h3\", null, \"Real life example\"), mdx(\"p\", null, \"As for real file example, I often use the YandexMaps API\\n(\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://api.yandex.com/maps/\"\n  }), \"http://api.yandex.com/maps/\"), \", API of\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://maps.yandex.com/\"\n  }), \"Yandex.Maps\"), \"\\npublic service). Yandex.Maps API has a complex loading scheme and this cannot be\\ndone synchronously. This means that I cannot simply link it to a page\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<script type=\\\"text/javascript\\\" src=\\\"url-of-ymaps.js\\\"></script>\"), \" and be sure that\\nall the following scripts will get the API code ready. First I need to wait for\\nthe event \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ymaps.ready\"), \" to fire.\"), mdx(\"p\", null, \"The project I am working for is quite complex; we have many classes inherited\\nfrom the basic API. For example, we have a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ComplexLayer\"), \" class based on \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ymaps.Layer\"), \".\\nWith YM modules it is simple to implement. We define a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ymaps\"), \" module which loads\\nthe API code, waits for the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ymaps.ready\"), \" event and then provides itself. All\\nthe modules which have the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ymaps\"), \" module as a dependency only start to resolve\\nafter this. As you can see, other modules know nothing about the asynchronicity of the\\nYandex.Map API. \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"No hacks in code!\")), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"ymaps.js:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"modules.define(\\n    'ymaps',\\n    ['loader', 'config'],\\n    function(provide, loader, config) {\\n\\n    var url = config.hosts.ymaps + '/2.1.4/?lang=ru-RU' +\\n              '&load=package.full&coordorder=longlat';\\n\\n    loader(url, function() {\\n        ymaps.ready(function() {\\n            provide(ymaps);\\n        });\\n    });\\n});\\n\")), mdx(\"p\", null, \"There are 2 other modules in use here: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"loader\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"config\"), \". I do not show\\ntheir code, but the first one loads scripts and the second one is a hash with\\nconstant values.\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"ComplexLayer.js:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"modules.define('ComplexLayer', ['inherit', 'ymaps'], function(provide, inherit, ymaps) {\\n    var ComplexLayer = inherit(ymaps.Layer, ...);\\n\\n    provide(ComplexLayer);\\n});\\n\")), mdx(\"p\", null, \"We can do the same if jQuery is needed. There is a module to load jQuery:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"modules.define(\\n    'jquery',\\n    ['loader',\\n    function(provide, loader) {\\n\\n    loader('//yandex.st/jquery/2.1.0/jquery.min.js', function() {\\n        provide(jQuery.noConflict(true));\\n    });\\n});\\n\")), mdx(\"p\", null, \"Then we make other modules dependent on \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"jquery\"), \" module.\"), mdx(\"p\", null, \"Thus, the whole project code is represented with modules. There is no global, no\\nneed for agreement on the order of linking the scripts (including third-party ones),\\nno dirty hacks for asynchronicity.\"), mdx(\"p\", null, \"And to wrap up, let me demonstrate you the YM modular system API (indeed, it has more\\nmethods, and these are only the basic ones).\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Defining a module:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"void modules.define(\\n    String moduleName,\\n    [String[] dependencies],\\n    Function(\\n        Function(Object objectToProvide) provide,\\n        [Object resolvedDependency, ...],\\n        [Object previousDeclaration]\\n    ) declarationFunction\\n)\\n\")), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Requiring a module:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"void modules.require(\\n    String[] dependencies,\\n    Function(\\n        [Object resolvedDependency, ...]\\n    ) callbackFunction\\n)\\n\")), mdx(\"p\", null, \"The project is open source and hosted at GitHub:\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/ymaps/modules\"\n  }), \"github.com/ymaps/modules\"), \".\"));\n}\n;\nMDXContent.isMDXComponent = true;","fields":{"readingTime":{"minutes":4.235},"slug":"en/posts/ym-modular-system/","prefix":"","disqusIdentifier":"en-issues-ym-modular-system"},"frontmatter":{"title":"YM Modular System. Why?","subTitle":null,"date":"25 February 2014","v2":null,"old":true,"tumblr":null,"meta":null,"cover":null}},"site":{"siteMetadata":{"siteUrl":"http://varya.me"}}},"pageContext":{"slug":"en/posts/ym-modular-system/","prev":{"id":"cd1efdd4-06e4-52f5-9fe8-c3d1e77bd05c","fileAbsolutePath":"/Users/varya/WebDev/Personal/varya.github.com/content/posts/what-makes-entrepreneurs-entrepreneurial/index_en.md","fields":{"slug":"en/posts/what-makes-entrepreneurs-entrepreneurial/","prefix":"","lang":"en","disqusIdentifier":"posts-what-makes-entrepreneurs-entrepreneurial-index-en","level":1,"fileRelativePath":"what-makes-entrepreneurs-entrepreneurial/index_en.md"},"frontmatter":{"title":"What   makes   entrepreneurs   entrepreneurial?","subTitle":null,"v2":true,"old":null,"date":"2018-01-04T00:00:00.000Z"}},"next":{"id":"3d97cf4f-34cc-5561-a084-1b76a1b49a3f","fileAbsolutePath":"/Users/varya/WebDev/Personal/varya.github.com/content/posts/xpath-prime-numbers/index_ru.md","fields":{"slug":"ru/posts/xpath-prime-numbers/","prefix":"","lang":"ru","disqusIdentifier":"ru-issues-xpath-prime-numbers","level":1,"fileRelativePath":"xpath-prime-numbers/index_ru.md"},"frontmatter":{"title":"Простые числа и XPath","subTitle":null,"v2":null,"old":true,"date":"2009-06-21T00:00:00.000Z"}},"fileSourceUrl":"https://github.com/varya/varya.github.com/edit/develop/content/posts/ym-modular-system/index_en.md"}}}