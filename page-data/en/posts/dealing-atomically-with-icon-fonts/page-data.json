{"componentChunkName":"component---src-components-layout-layout-post-js","path":"/en/posts/dealing-atomically-with-icon-fonts/","result":{"data":{"mdx":{"id":"cfe1845e-9b45-57f4-b6a4-d738d926d20d","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Dealing atomically with icon fonts\",\n  \"date\": \"2015-11-10T00:00:00.000Z\",\n  \"v2\": true,\n  \"cover\": \"thumb.png\",\n  \"layout\": \"post\",\n  \"meta\": {\n    \"desc\": \"Fixing the \\\"using UI library\\\" workflow with building icon fonts from atomic SVG icons. The library has its own flow, and obviously the new things can only appear in new versions. However the library customers sometimes cannot wait even an hour. With the atomic builds you can easily provide library customer with the freedom to modify everything. Even icon fonts.\\n\"\n  }\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"My recent huge project was developing a library of CSS and JavaScript components for sharing this code across a lot of\\nweb services and mobile apps. In most cases such work brings up question about how to avoid blocking the processes.\"), mdx(\"p\", null, \"The library has its own flow, and obviously the new things can only appear in new versions. Although I made my best to\\nprovide fast releases, and so the library has them 2-3 times a week, it is still understandable that the library\\ncustomers sometimes cannot wait even an hour.\"), mdx(\"p\", null, \"I belive that one of the must-haves of UI library is the freedom which it should give to its customers. You can easily\\nprovide this if practice atomic approach everythere. For example, for the icon fonts.\"), mdx(\"excerpt\", null), mdx(\"h3\", null, \"Solid piece\"), mdx(\"p\", null, \"Soon or not SVG will conquer the world. But now we still have icon fonts in some projects. The same story was with that\\nlibrary.\"), mdx(\"p\", null, \"However the icon font perfectly suited for the displaying icons onto the web pages, it was integration and flow which\\ncreated the problem. All the icons fit into one font file (well, in 4 different formats):\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"src/\\n  fonts/\\n    iconfont.eot\\n    iconfont.svg\\n    iconfont.ttf\\n    iconfont.woff\\n\")), mdx(\"p\", null, \"Also the library provided CSS to make the icon-symbol matching:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-scss\"\n  }), \".icon {\\n  font-family: $global-font-icon;\\n  &:before {\\n    /* Some common icon stuff */\\n  }\\n  &--support {\\n    &:before {\\n      content: \\\"a\\\";\\n    }\\n  }\\n  &--chat {\\n    &:before {\\n      content: \\\"b\\\";\\n    }\\n  }\\n  ...\\n}\\n\")), mdx(\"p\", null, \"Customers get the library as a bower or npm package. When they need a new icon to be in the set, they might request this\\nand wait for the package to update. As usual, the fastest way to get something happened is to do this yourself. So, it\\npossible to contribute and even release yourself. But still any further change would need you to go through the\\ndevelopment process.\"), mdx(\"h3\", null, \"Atomic and buildable\"), mdx(\"p\", null, \"Often you need to divide into smaller pieces in order to make things more mantainable. The same goes with icons. In the\\nlibrary we changed it so that the source is now a set of SVG files:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"src/\\n  icons/\\n    1000-support.svg\\n    1010-chat.svg\\n    1020-users.svg\\n\")), mdx(\"p\", null, \"The file names are important, these words are used to generate the CSS classes, which are the API for the customer.\\nNumbers are for the right order. If building the icon system from very beginning, they are not needed. But in the\\nlibrary case I wanted backward compatibility.\"), mdx(\"p\", null, \"Then, these icons are built into the same icon fonts with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gulp-iconfont\"), \" plugin:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"var gulp = require(\\\"gulp\\\");\\nvar iconfont = require(\\\"gulp-iconfont\\\");\\nvar consolidate = require(\\\"gulp-consolidate\\\");\\n\\nvar sourcePath = \\\"src/\\\";\\n\\ngulp.task(\\\"build:icons\\\", function() {\\n    return gulp.src([sourcePath + \\\"/icons/*.svg\\\"])\\n      .pipe(iconfont({\\n        fontName: \\\"myicons\\\",\\n        formats: [\\\"ttf\\\", \\\"eot\\\", \\\"woff\\\", \\\"svg\\\"],\\n        centerHorizontally: true,\\n        fixedWidth: true\\n      }))\\n      .on(\\\"glyphs\\\", (glyphs) => {\\n\\n        glyphs.forEach((icon) => {\\n          icon.name = icon.name.replace(/^\\\\d+\\\\-/g, \\\"\\\");\\n        });\\n\\n        gulp.src(sourcePath + \\\"/icons/util/*.scss\\\") // Template\\n            .pipe(consolidate(\\\"lodash\\\", {\\n                glyphs: glyphs,\\n                fontName: \\\"myiconfont\\\",\\n                fontPath: \\\"../fonts/\\\"\\n            }))\\n            .pipe(gulp.dest(sourcePath + \\\"/scss/\\\"));\\n      })\\n      .pipe(gulp.dest(sourcePath + \\\"/fonts/\\\"));\\n});\\n\")), mdx(\"p\", null, \"Besides the icon files this task needs the templates to produce the CSS (or SCSS, as in this case) which makes the\\nsymbol-class matching. I found it logical to store it together with the icon files:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"src/\\n  icons/\\n    utils/\\n      iconfont__icons.scss\\n      iconfont__variables.scss\\n\")), mdx(\"p\", null, \"It's possible to manage with one template only, but for even more flexibility I have two. The main one makes the\\nclasses:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-css\"\n  }), \"@font-face {\\n  font-family: $global-font-icon;\\n  src:url(\\\"<%= fontPath %><%= fontName %>..eot\\\");\\n  src:url(\\\"<%= fontPath %><%= fontName %>.?#iefix\\\") format(\\\"embedded-opentype\\\"),\\n    url(\\\"<%= fontPath %><%= fontName %>.woff\\\") format(\\\"woff\\\"),\\n    url(\\\"<%= fontPath %><%= fontName %>.ttf\\\") format(\\\"truetype\\\"),\\n    url(\\\"<%= fontPath %><%= fontName %>.#<%= fontName %>\\\") format(\\\"svg\\\");\\n  font-weight: normal;\\n  font-style: normal;\\n}\\n\\n.icon {\\n  font-family: $global-font-icon;\\n\\n  &:before {\\n    /* Some common icon stuff */\\n  }\\n<% _.each(glyphs, function(glyph) { %>\\n  &.--<%= glyph.name %> {\\n    &:before {\\n      content: $icon--<%= glyph.name %>;\\n    }\\n  }<% }); %>\\n\\n}\\n\")), mdx(\"p\", null, \"And another one makes the varibles:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-css\"\n  }), \"<% _.each(glyphs, function(glyph) { %>\\n$icon-<%= glyph.name %>: \\\"\\\\<%= glyph.unicode[0].charCodeAt(0).toString(16).toUpperCase() %>\\\" !default;\\n<% }); %>\\n\")), mdx(\"p\", null, \"Running the task produces the fonts and 2 generic SCSS files:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"src/\\n  font/\\n    iconfont.eot\\n    iconfont.svg\\n    iconfont.ttf\\n    iconfont.woff\\n  scss/\\n    icons.scss // Not generic\\n    iconfont__icons.scss\\n    iconfont__variables.scss\\n\")), mdx(\"p\", null, \"In the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"icons.scss\"), \", which is normal SCSS file, the result is requested:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-css\"\n  }), \"// Icons\\n//\\n// Lists all the icons that are used in the services.\\n//\\n// Styleguide 5\\n\\n@import \\\"iconfont__variables.scss\\\";\\n@import \\\"iconfont__icons.scss\\\";\\n\")), mdx(\"h3\", null, \"Extend on fly\"), mdx(\"p\", null, \"The variables may be redefined on the customer's side. This makes is a fast way to change the icon, if the replacement\\nalready sit in the font bundle.\"), mdx(\"p\", null, \"If not, it is almost zero amout of work to implement this build-from-atoms process on the customer side.\"), mdx(\"p\", null, \"The customer has all the library code, let's say in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bower_components\"), \", and can have its own folder of icons:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"bower_components/\\n  ui-library/\\n    dist/\\n      icons/\\n      scss/\\nsrc/\\n  icons/\\n    2000-rabbit.svg\\n    2010-gift.svg\\n\")), mdx(\"p\", null, \"When building the font they need to use both their set of icons and the library icons:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"\\nvar sourcePath = \\\"src/\\\";\\n\\ngulp.task(\\\"build:icons\\\", function() {\\n    return gulp.src([sourcePath + \\\"/icons/*.svg\\\", \\\"bower_components/ui-library/dist/icons/*.svg\\\"])\\n      .pipe(iconfont({\\n        /* The same as above */\\n      }))\\n      .on(\\\"glyphs\\\", (glyphs) => {\\n\\n        gulp.src(\\\"bower_components/ui-library/dist/icons/util/*.scss\\\")\\n            .pipe(consolidate(\\\"lodash\\\", {\\n                /* The same as above */\\n            }))\\n            .pipe(gulp.dest(sourcePath + \\\"/scss/\\\"));\\n      })\\n      .pipe(gulp.dest(sourcePath + \\\"/fonts/\\\"));\\n});\\n\")), mdx(\"p\", null, \"It is not even needed to implement template for the output SCSS, it comes in the library dist.\"), mdx(\"p\", null, \"With such a flow a UI library customer stays completely independent from the library release cycle and may bring a new\\nicon into her product as soon as the atomic SVG file is copied into the needed folder. As a background process it is\\nneeded to contribute the same icon into the library, but not necessarily the same moment. And even the contributing\\nprocess is changed to be better because it came to adding an SVG file.\"), mdx(\"p\", null, \"As other atomical things, such font flow makes git history more useful. Now it is easier to see\\nif the provided change affected many or just one icon. Also, SVG images are rendered nicely in pull requests.\"), mdx(\"p\", null, \"Even simultaneous changes of the icons in both library and customer websites are possible and should not cause any\\nconflict.\"), mdx(\"p\", null, \"And the last but not least nice thing: all the icons are now in the library as SVG files. Hopefully later we come up\\nwith using next century technologies and not the icons fonts. When this sweet moment comes, half of the work will have\\nbeen done :-)\"));\n}\n;\nMDXContent.isMDXComponent = true;","fields":{"readingTime":{"minutes":5.69},"slug":"en/posts/dealing-atomically-with-icon-fonts/","prefix":"","disqusIdentifier":"posts-dealing-atomically-with-icon-fonts-index-en"},"frontmatter":{"title":"Dealing atomically with icon fonts","subTitle":null,"date":"10 November 2015","v2":true,"old":null,"tumblr":null,"meta":{"desc":"Fixing the \"using UI library\" workflow with building icon fonts from atomic SVG icons. The library has its own flow, and obviously the new things can only appear in new versions. However the library customers sometimes cannot wait even an hour. With the atomic builds you can easily provide library customer with the freedom to modify everything. Even icon fonts.\n"},"cover":{"childImageSharp":{"resize":{"src":"/static/5ff1b90224ede4179ee3616d1d5da5ee/630fb/thumb.png"}}}}},"site":{"siteMetadata":{"siteUrl":"http://varya.me"}}},"pageContext":{"slug":"en/posts/dealing-atomically-with-icon-fonts/","prev":{"id":"5ea2faa4-fe64-57a4-82b8-d2de67d813f3","fileAbsolutePath":"/Users/varya/WebDev/Personal/varya.github.com/content/posts/communication-culture/index_en.md","fields":{"slug":"en/posts/communication-culture/","prefix":"","lang":"en","disqusIdentifier":"posts-communication-culture-index-en","level":1,"fileRelativePath":"communication-culture/index_en.md"},"frontmatter":{"title":"Aspect of in-company communication for innovation","subTitle":null,"v2":true,"old":null,"date":"2018-01-11T00:00:00.000Z"}},"next":{"id":"fa1fd891-7452-5c13-8d73-32f15e44e9a1","fileAbsolutePath":"/Users/varya/WebDev/Personal/varya.github.com/content/posts/docpad-with-bem-taste/index_en.md","fields":{"slug":"en/posts/docpad-with-bem-taste/","prefix":"","lang":"en","disqusIdentifier":"posts-docpad-with-bem-taste-index-en","level":1,"fileRelativePath":"docpad-with-bem-taste/index_en.md"},"frontmatter":{"title":"Docpad with the taste of BEM","subTitle":null,"v2":true,"old":null,"date":"2014-06-04T00:00:00.000Z"}},"fileSourceUrl":"https://github.com/varya/varya.github.com/edit/develop/content/posts/dealing-atomically-with-icon-fonts/index_en.md"}}}